<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strava Visualization</title>

    <!-- CDN Links -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    
    <!-- Load Tailwind with PostCSS for production -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>

    <!-- Configuration -->
    <script>
        // Load configuration
        window.APP_CONFIG = {
            API_BASE_URL: 'http://localhost:3000/api'
        };
    </script>

    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'strava-orange': '#fc4c02'
                    }
                }
            }
        }
    </script>

    <style type="text/css">
        body {
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(to bottom right, #1a202c, #2d3748, #000000);
            color: white;
            overflow-x: hidden;
        }

        .glass {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .blob {
            position: absolute;
            transition: transform 0.5s ease;
            will-change: transform;
            filter: blur(30px);
            mix-blend-mode: screen;
            pointer-events: none;
        }

        .blob-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 0.5; }
        }

        .pulse {
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0px); }
        }

        .float {
            animation: float 6s ease-in-out infinite;
        }

        @keyframes blob {
            0% { transform: translate(0px, 0px) scale(1); }
            33% { transform: translate(30px, -50px) scale(1.1); }
            66% { transform: translate(-20px, 20px) scale(0.9); }
            100% { transform: translate(0px, 0px) scale(1); }
        }
        .animate-blob {
            animation: blob 7s infinite;
        }
        .animation-delay-2000 {
            animation-delay: 2s;
        }
        .animation-delay-4000 {
            animation-delay: 4s;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- Main App Code -->
    <script type="text/babel">
        // Interactive Background Component
        function InteractiveBackground() {
            const [mousePos, setMousePos] = React.useState({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
            const blobRefs = React.useRef([]);
            const initialPositions = React.useRef(null);
            
            // Initialize random positions on mount
            React.useEffect(() => {
                initialPositions.current = Array(5).fill(0).map(() => ({
                    x: Math.random() * (window.innerWidth - 400),
                    y: Math.random() * (window.innerHeight - 400),
                    rotation: Math.random() * 360,
                    scale: 0.8 + Math.random() * 0.4
                }));
            }, []);
            
            React.useEffect(() => {
                const handleMouseMove = (e) => {
                    const newMousePos = { x: e.clientX, y: e.clientY };
                    setMousePos(newMousePos);
                    
                    blobRefs.current.forEach((blob, index) => {
                        if (!blob || !initialPositions.current) return;
                        
                        const initialPos = initialPositions.current[index];
                        const rect = blob.getBoundingClientRect();
                        const blobCenterX = rect.left + rect.width / 2;
                        const blobCenterY = rect.top + rect.height / 2;
                        
                        const deltaX = newMousePos.x - blobCenterX;
                        const deltaY = newMousePos.y - blobCenterY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        const maxDistance = 500;
                        const influence = Math.max(0, 1 - distance / maxDistance);
                        
                        // Calculate spring-like movement
                        const springStrength = 0.15;
                        const moveX = deltaX * influence * springStrength;
                        const moveY = deltaY * influence * springStrength;
                        
                        // Add some noise to the movement
                        const noise = Math.sin(Date.now() * 0.001 + index) * 2;
                        
                        // Calculate rotation based on movement direction
                        const rotation = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                        
                        // Scale based on mouse proximity
                        const scale = initialPos.scale + influence * 0.3;
                        
                        // Apply transforms
                        const transform = 'translate(' + (moveX + noise) + 'px, ' + (moveY + noise) + 'px) ' +
                                       'rotate(' + (rotation + initialPos.rotation) + 'deg) ' +
                                       'scale(' + scale + ')';
                        blob.style.transform = transform;
                        
                        // Adjust transition based on distance
                        const transitionSpeed = 0.2 + influence * 0.3;
                        blob.style.transition = `transform ${transitionSpeed}s cubic-bezier(0.34, 1.56, 0.64, 1)`;
                    });
                };
                
                const handleResize = () => {
                    // Update initial positions on resize
                    initialPositions.current = Array(5).fill(0).map(() => ({
                        x: Math.random() * (window.innerWidth - 400),
                        y: Math.random() * (window.innerHeight - 400),
                        rotation: Math.random() * 360,
                        scale: 0.8 + Math.random() * 0.4
                    }));
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('resize', handleResize);
                
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('resize', handleResize);
                };
            }, []);

            const colors = [
                'rgba(252, 76, 2, 0.6)',    // Strava orange
                'rgba(59, 130, 246, 0.6)',   // Blue
                'rgba(139, 92, 246, 0.6)',   // Purple
                'rgba(236, 72, 153, 0.6)',   // Pink
                'rgba(16, 185, 129, 0.6)'    // Green
            ];

            return (
                <div className="blob-container">
                    {colors.map((color, index) => {
                        const initialPos = initialPositions.current ? initialPositions.current[index] : {
                            x: Math.random() * (window.innerWidth - 400),
                            y: Math.random() * (window.innerHeight - 400),
                            rotation: Math.random() * 360,
                            scale: 0.8 + Math.random() * 0.4
                        };
                        
                        return (
                            <div
                                key={index}
                                ref={el => blobRefs.current[index] = el}
                                className="blob"
                                style={{
                                    backgroundColor: color,
                                    width: '400px',
                                    height: '400px',
                                    borderRadius: '50%',
                                    position: 'absolute',
                                    left: initialPos.x + 'px',
                                    top: initialPos.y + 'px',
                                    transform: `rotate(${initialPos.rotation}deg) scale(${initialPos.scale})`,
                                    transition: 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)',
                                    filter: 'blur(50px)',
                                    opacity: 0.8
                                }}
                            />
                        );
                    })}
                </div>
            );
        }

        // AI Coach Component
        function AICoach({ activities }) {
            const [analysis, setAnalysis] = React.useState(null);
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState(null);

            const analyzeActivities = async () => {
                setLoading(true);
                setError(null);

                try {
                    // Prepare the data for OpenAI
                    const recentActivities = activities.slice(0, 5).map(activity => ({
                        name: activity.name,
                        type: activity.type,
                        distance: (activity.distance / 1000).toFixed(1),
                        duration: Math.floor(activity.moving_time / 60),
                        speed: (activity.average_speed * 3.6).toFixed(1),
                        date: dayjs(activity.start_date).format('MMM d, YYYY')
                    }));

                    // Make request to OpenAI API through our server
                    const response = await fetch(`${window.APP_CONFIG.API_BASE_URL}/ai/analyze`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            activities: recentActivities,
                            prompt: `As an AI sports coach, analyze these recent activities and provide training advice:
                                ${JSON.stringify(recentActivities, null, 2)}
                                
                                Please provide:
                                1. A brief analysis of the training pattern
                                2. Suggestions for improvement
                                3. Recovery recommendations
                                4. A potential training plan for the next week`
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to get AI analysis');
                    }

                    const data = await response.json();
                    setAnalysis(data.choices[0].message.content);
                } catch (err) {
                    console.error('Error getting AI analysis:', err);
                    setError('Failed to get AI analysis. Please try again.');
                } finally {
                    setLoading(false);
                }
            };

            if (!activities || activities.length === 0) {
                return (
                    <div className="text-center py-12">
                        <p className="text-gray-400">No activities available for analysis</p>
                    </div>
                );
            }

            return (
                <div className="space-y-6">
                    <div className="flex justify-between items-center">
                        <h2 className="text-2xl font-bold">AI Coach Analysis</h2>
                        <button
                            onClick={analyzeActivities}
                            disabled={loading}
                            className="bg-strava-orange hover:bg-orange-600 text-white px-4 py-2 rounded transition-colors duration-200"
                        >
                            {loading ? 'Analyzing...' : 'Get Analysis'}
                        </button>
                    </div>

                    {error && (
                        <div className="bg-red-500 bg-opacity-20 text-red-100 p-4 rounded">
                            {error}
                        </div>
                    )}

                    {loading && (
                        <div className="flex justify-center items-center py-12">
                            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-strava-orange"></div>
                        </div>
                    )}

                    {analysis && !loading && (
                        <div className="glass p-6 rounded-lg space-y-4">
                            {analysis.split('\n').map((line, index) => (
                                <p key={index} className="text-gray-300">
                                    {line}
                                </p>
                            ))}
                        </div>
                    )}

                    {/* Recent Activities Summary */}
                    <div className="glass p-6 rounded-lg">
                        <h3 className="text-xl font-semibold mb-4">Recent Activities</h3>
                        <div className="space-y-4">
                            {activities.slice(0, 5).map((activity) => (
                                <div key={activity.id} className="flex justify-between items-center">
                                    <div>
                                        <h4 className="font-semibold">{activity.name}</h4>
                                        <p className="text-sm text-gray-400">
                                            {dayjs(activity.start_date).format('MMM d, YYYY')} â€¢ {(activity.distance / 1000).toFixed(1)} km
                                        </p>
                                    </div>
                                    <div className="text-right">
                                        <p className="text-sm text-gray-400">{activity.type}</p>
                                        <p className="text-sm text-gray-400">{((activity.average_speed * 3.6).toFixed(1))} km/h</p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        // Training Load Component
        function TrainingLoad({ activities }) {
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState(null);
            const acwrChartRef = React.useRef(null);
            const intensityChartRef = React.useRef(null);
            const volumeChartRef = React.useRef(null);
            const biomechanicsChartRef = React.useRef(null);

            // Get athlete data from localStorage
            const athlete = React.useMemo(() => {
                const storedAthlete = localStorage.getItem('athlete');
                return storedAthlete ? JSON.parse(storedAthlete) : { age: 30 };
            }, []);

            React.useEffect(() => {
                if (activities.length > 0) {
                    createACWRChart();
                    createIntensityChart();
                    createVolumeChart();
                    createBiomechanicsChart();
                }
            }, [activities]);

            const calculateACWR = () => {
                const now = dayjs();
                const oneWeekAgo = now.subtract(1, 'week');
                const fourWeeksAgo = now.subtract(4, 'weeks');

                const acuteLoad = activities
                    .filter(a => dayjs(a.start_date).isAfter(oneWeekAgo))
                    .reduce((sum, a) => sum + a.distance/1000, 0);

                const chronicLoad = activities
                    .filter(a => 
                        dayjs(a.start_date).isAfter(fourWeeksAgo) &&
                        dayjs(a.start_date).isBefore(oneWeekAgo)
                    )
                    .reduce((sum, a) => sum + a.distance/1000, 0) / 3;

                return acuteLoad / chronicLoad;
            };

            const createACWRChart = () => {
                const ctx = acwrChartRef.current.getContext('2d');
                const acwr = calculateACWR();
                
                new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        datasets: [{
                            data: [acwr, 2 - acwr], // Creates a semi-circle effect
                            backgroundColor: [
                                acwr < 0.8 ? '#FFC107' : 
                                acwr > 1.3 ? '#f44336' : '#4CAF50',
                                'rgba(0, 0, 0, 0)' // Transparent for the remaining portion
                            ],
                            borderWidth: 0,
                            circumference: 180,
                            rotation: 270
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '80%',
                        plugins: {
                            tooltip: { enabled: false },
                            legend: { display: false },
                            title: {
                                display: true,
                                text: 'Acute:Chronic Workload Ratio',
                                color: 'white',
                                padding: { bottom: 30 }
                            }
                        },
                        layout: {
                            padding: {
                                bottom: 30
                            }
                        }
                    },
                    plugins: [{
                        id: 'acwrText',
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            const xCenter = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
                            const yCenter = chart.chartArea.bottom;
                            
                            ctx.save();
                            ctx.fillStyle = 'white';
                            ctx.font = '20px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(acwr.toFixed(2), xCenter, yCenter - 20);
                            
                            ctx.font = '14px Arial';
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.fillText('ACWR', xCenter, yCenter + 10);
                            ctx.restore();
                        }
                    }]
                });
            };

            const createIntensityChart = () => {
                const ctx = intensityChartRef.current.getContext('2d');
                
                // Calculate intensity distribution based on heart rate zones
                const intensityData = activities.reduce((acc, activity) => {
                    // Using heart rate zones based on max HR percentage
                    // Zone 1 (Easy): < 70% max HR
                    // Zone 2 (Moderate): 70-80% max HR
                    // Zone 3 (Hard): > 80% max HR
                    const maxHR = 220 - (athlete.age || 30); // Estimate max HR if age not available
                    const avgHR = activity.average_heartrate;
                    
                    if (!avgHR) {
                        // If no HR data, don't count in zones
                        return acc;
                    }

                    const hrPercentage = (avgHR / maxHR) * 100;
                    
                    if (hrPercentage < 70) acc.easy++;
                    else if (hrPercentage < 80) acc.moderate++;
                    else acc.hard++;
                    
                    return acc;
                }, { easy: 0, moderate: 0, hard: 0 });

                const total = Object.values(intensityData).reduce((a, b) => a + b, 0);
                const data = {
                    labels: ['Easy (Zone 1-2)', 'Moderate (Zone 3)', 'Hard (Zone 4-5)'],
                    datasets: [{
                        data: Object.values(intensityData).map(v => total > 0 ? (v/total * 100).toFixed(1) : 0),
                        backgroundColor: ['#4CAF50', '#FFC107', '#f44336'],
                        borderWidth: 1
                    }]
                };

                new Chart(ctx, {
                    type: 'doughnut',
                    data: data,
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Training Intensity Distribution (Heart Rate Zones)',
                                color: 'white'
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: 'white' }
                            }
                        }
                    }
                });
            };

            const createVolumeChart = () => {
                const ctx = volumeChartRef.current.getContext('2d');
                
                // Calculate weekly volume trend
                const weeklyVolume = activities.reduce((acc, activity) => {
                    const week = dayjs(activity.start_date).startOf('week').format('YYYY-MM-DD');
                    if (!acc[week]) acc[week] = 0;
                    acc[week] += activity.distance / 1000;
                    return acc;
                }, {});

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: Object.keys(weeklyVolume).map(w => `Week of ${dayjs(w).format('MMM d')}`),
                        datasets: [{
                            label: 'Weekly Volume (km)',
                            data: Object.values(weeklyVolume),
                            borderColor: '#fc4c02',
                            backgroundColor: 'rgba(252, 76, 2, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Weekly Training Volume',
                                color: 'white'
                            },
                            legend: {
                                labels: { color: 'white' }
                            }
                        },
                        scales: {
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' }
                            }
                        }
                    }
                });
            };

            const createBiomechanicsChart = () => {
                const ctx = biomechanicsChartRef.current.getContext('2d');
                
                // Analyze cadence and stride length trends
                const biomechanicsData = activities.reduce((acc, activity) => {
                    if (activity.average_cadence) {
                        // Convert cadence from steps/min to strides/min (divide by 2)
                        const cadence = activity.average_cadence / 2;
                        
                        // Calculate stride length in meters
                        // Speed (m/s) = Cadence (strides/min) * Stride Length (m) / 60
                        const speedMS = activity.average_speed;
                        const strideLengthM = (speedMS * 60) / (cadence);
                        
                        acc.push({
                            date: activity.start_date,
                            cadence: cadence,
                            strideLength: strideLengthM
                        });
                    }
                    return acc;
                }, []);

                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: biomechanicsData.map(d => dayjs(d.date).format('MMM d')),
                        datasets: [
                            {
                                label: 'Cadence (strides/min)',
                                data: biomechanicsData.map(d => d.cadence),
                                borderColor: '#4CAF50',
                                yAxisID: 'y-cadence'
                            },
                            {
                                label: 'Stride Length (m)',
                                data: biomechanicsData.map(d => d.strideLength),
                                borderColor: '#FFC107',
                                yAxisID: 'y-stride'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Running Biomechanics Trends',
                                color: 'white'
                            },
                            legend: {
                                labels: { color: 'white' }
                            }
                        },
                        scales: {
                            'y-cadence': {
                                type: 'linear',
                                position: 'left',
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' },
                                title: {
                                    display: true,
                                    text: 'Cadence (strides/min)',
                                    color: 'white'
                                }
                            },
                            'y-stride': {
                                type: 'linear',
                                position: 'right',
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' },
                                title: {
                                    display: true,
                                    text: 'Stride Length (m)',
                                    color: 'white'
                                }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' }
                            }
                        }
                    }
                });
            };

            const trainingStatus = {
                acwr: calculateACWR(),
                status: calculateACWR() < 0.8 ? 'Undertraining' : calculateACWR() > 1.3 ? 'High Risk' : 'Optimal',
                color: calculateACWR() < 0.8 ? '#FFC107' : calculateACWR() > 1.3 ? '#f44336' : '#4CAF50'
            };

            return (
                <div className="space-y-6">
                    {/* Training Status Card */}
                    <div className="glass p-6 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="text-xl font-semibold mb-2">Training Status</h3>
                                <div className="flex items-center space-x-2">
                                    <div 
                                        className="w-3 h-3 rounded-full"
                                        style={{ backgroundColor: trainingStatus.color }}
                                    ></div>
                                    <span className="text-lg">{trainingStatus.status}</span>
                                </div>
                            </div>
                            <div className="text-right">
                                <div className="text-sm text-gray-400">Acute:Chronic Ratio</div>
                                <div className="text-2xl font-bold">{trainingStatus.acwr.toFixed(2)}</div>
                            </div>
                        </div>
                    </div>

                    {/* Charts Grid */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div className="glass p-6 rounded-lg">
                            <canvas ref={acwrChartRef}></canvas>
                        </div>
                        <div className="glass p-6 rounded-lg">
                            <canvas ref={intensityChartRef}></canvas>
                        </div>
                    </div>

                    <div className="glass p-6 rounded-lg">
                        <canvas ref={volumeChartRef}></canvas>
                    </div>

                    {/* New Biomechanics Chart */}
                    <div className="glass p-6 rounded-lg">
                        <canvas ref={biomechanicsChartRef}></canvas>
                    </div>

                    {/* Heart Rate Zone Explanation */}
                    <div className="glass p-6 rounded-lg">
                        <h3 className="text-xl font-semibold mb-4">Heart Rate Training Zones</h3>
                        <div className="space-y-4">
                            <div>
                                <div className="flex items-center mb-2">
                                    <div className="w-4 h-4 rounded-full bg-green-500 mr-2"></div>
                                    <span className="font-semibold">Zone 1-2 (Easy): &lt;70% Max HR</span>
                                </div>
                                <p className="text-gray-400 text-sm">Recovery and base building. Should be your most common training zone.</p>
                            </div>
                            <div>
                                <div className="flex items-center mb-2">
                                    <div className="w-4 h-4 rounded-full bg-yellow-500 mr-2"></div>
                                    <span className="font-semibold">Zone 3 (Moderate): 70-80% Max HR</span>
                                </div>
                                <p className="text-gray-400 text-sm">Aerobic endurance. Good for tempo runs and sustained efforts.</p>
                            </div>
                            <div>
                                <div className="flex items-center mb-2">
                                    <div className="w-4 h-4 rounded-full bg-red-500 mr-2"></div>
                                    <span className="font-semibold">Zone 4-5 (Hard): &gt;80% Max HR</span>
                                </div>
                                <p className="text-gray-400 text-sm">High intensity. Use sparingly for intervals and race-specific training.</p>
                            </div>
                        </div>
                    </div>

                    {/* Injury Prevention Metrics */}
                    <div className="glass p-6 rounded-lg">
                        <h3 className="text-xl font-semibold mb-4">Injury Prevention Metrics</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h4 className="font-semibold mb-2">Cadence Analysis</h4>
                                <p className="text-gray-400 text-sm">
                                    Optimal running cadence is typically 170-180 steps per minute. 
                                    Lower cadence may increase impact forces and injury risk.
                                </p>
                            </div>
                            <div>
                                <h4 className="font-semibold mb-2">Stride Length</h4>
                                <p className="text-gray-400 text-sm">
                                    Sudden increases in stride length may indicate fatigue or increased injury risk. 
                                    Monitor for consistent patterns.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Race Predictions Component
        function RacePredictions({ activities }) {
            const [predictions, setPredictions] = React.useState(null);
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState(null);

            const calculatePredictions = () => {
                // Find best recent performance
                const recentActivities = activities.slice(0, 20);
                let bestPace = 0;
                
                recentActivities.forEach(activity => {
                    if (activity.distance > 3000) { // Only consider runs longer than 3K
                        const pace = activity.average_speed;
                        if (pace > bestPace) bestPace = pace;
                    }
                });

                // Use a variation of Riegel's formula for predictions
                const predictions = {
                    '5K': predictTime(5000, bestPace),
                    '10K': predictTime(10000, bestPace),
                    'Half': predictTime(21097.5, bestPace),
                    'Marathon': predictTime(42195, bestPace)
                };

                setPredictions(predictions);
            };

            const predictTime = (distance, basePace) => {
                // Riegel's formula with fatigue factor
                const baseDistance = 5000; // Use 5K as base
                const fatigueFactor = 1.06;
                const predictedTime = (baseDistance / basePace) * Math.pow(distance/baseDistance, fatigueFactor);
                return predictedTime;
            };

            React.useEffect(() => {
                if (activities.length > 0) {
                    calculatePredictions();
                }
            }, [activities]);

            const formatTime = (seconds) => {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                return hours > 0 
                    ? `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
                    : `${minutes}:${secs.toString().padStart(2, '0')}`;
            };

            const getConfidence = (distance) => {
                const recentLongRuns = activities
                    .filter(a => a.distance >= distance * 0.75)
                    .length;
                
                if (recentLongRuns >= 3) return { level: 'High', color: '#4CAF50' };
                if (recentLongRuns >= 1) return { level: 'Medium', color: '#FFC107' };
                return { level: 'Low', color: '#f44336' };
            };

            if (!activities || activities.length === 0) {
                return (
                    <div className="text-center py-12">
                        <p className="text-gray-400">No activities available for predictions</p>
                    </div>
                );
            }

            return (
                <div className="space-y-6">
                    {/* Race Cards Grid */}
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                        {predictions && Object.entries(predictions).map(([race, time]) => {
                            const confidence = getConfidence(race === '5K' ? 5000 : 
                                race === '10K' ? 10000 : 
                                race === 'Half' ? 21097.5 : 42195);
                            
                            return (
                                <div key={race} 
                                    className="glass p-6 rounded-lg text-center transform hover:scale-105 transition-all duration-300"
                                    style={{ borderLeft: `4px solid ${confidence.color}` }}
                                >
                                    <div className="text-4xl font-bold mb-2">{race}</div>
                                    <div className="text-2xl text-strava-orange">{formatTime(time)}</div>
                                    <div className="mt-2 flex items-center justify-center space-x-2">
                                        <div 
                                            className="w-2 h-2 rounded-full"
                                            style={{ backgroundColor: confidence.color }}
                                        ></div>
                                        <span className="text-sm text-gray-400">{confidence.level} confidence</span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Training Paces Guide */}
                    <div className="glass p-6 rounded-lg">
                        <h3 className="text-xl font-semibold mb-4">Recommended Training Paces</h3>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {predictions && [
                                { name: 'Easy', factor: 1.3, icon: 'ðŸŒŸ' },
                                { name: 'Tempo', factor: 1.1, icon: 'âš¡' },
                                { name: 'Intervals', factor: 1.0, icon: 'ðŸ”¥' }
                            ].map(pace => {
                                const baseTime = predictions['5K'] / 5; // Time per km at 5K race pace
                                const paceTime = baseTime * pace.factor;
                                const paceMin = Math.floor(paceTime / 60);
                                const paceSec = Math.floor(paceTime % 60);
                                
                                return (
                                    <div key={pace.name} 
                                        className="text-center p-4 rounded-lg bg-black bg-opacity-20 transform hover:scale-105 transition-all duration-300"
                                    >
                                        <div className="text-2xl mb-2">{pace.icon}</div>
                                        <div className="text-lg font-semibold">{pace.name}</div>
                                        <div className="text-xl text-strava-orange">
                                            {paceMin}:{paceSec.toString().padStart(2, '0')}/km
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        }

        function App() {
            const [athlete, setAthlete] = React.useState(null);
            const [activities, setActivities] = React.useState([]);
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState(null);
            const [activeTab, setActiveTab] = React.useState('dashboard');
            const [mainStats, setMainStats] = React.useState({
                distance: '0 km',
                time: '0 hrs',
                count: '0'
            });

            const handleStravaConnect = async () => {
                try {
                    const response = await fetch(`${window.APP_CONFIG.API_BASE_URL}/auth/strava`);
                    const data = await response.json();
                    
                    if (data.authUrl === '/mock-auth') {
                        // Handle mock auth
                        const mockResponse = await fetch(`${window.APP_CONFIG.API_BASE_URL}/mock-auth`);
                        const mockData = await mockResponse.json();
                        
                        // Store the mock tokens and athlete data
                        localStorage.setItem('access_token', mockData.access_token);
                        localStorage.setItem('refresh_token', mockData.refresh_token);
                        localStorage.setItem('athlete', JSON.stringify(mockData.athlete));
                        
                        // Update state
                        setAthlete(mockData.athlete);
                        
                        // Fetch activities immediately after mock auth
                        const activitiesResponse = await fetch(
                            `${window.APP_CONFIG.API_BASE_URL}/strava/activities?access_token=${mockData.access_token}`
                        );
                        const activitiesData = await activitiesResponse.json();
                        if (Array.isArray(activitiesData)) {
                            setActivities(activitiesData);
                            const totalDistance = activitiesData.reduce((sum, activity) => sum + activity.distance, 0) / 1000;
                            const totalTime = activitiesData.reduce((sum, activity) => sum + activity.moving_time, 0) / 3600;
                            setMainStats({
                                distance: `${totalDistance.toFixed(1)} km`,
                                time: `${totalTime.toFixed(1)} hrs`,
                                count: activitiesData.length.toString()
                            });
                        }
                    } else {
                        // Real Strava auth flow
                        window.location.href = data.authUrl;
                    }
                } catch (error) {
                    console.error('Failed to initiate Strava auth:', error);
                    setError('Failed to connect with Strava');
                }
            };

            React.useEffect(() => {
                // Check if we have stored athlete data
                const storedAthlete = localStorage.getItem('athlete');
                const accessToken = localStorage.getItem('access_token');
                
                if (storedAthlete && accessToken) {
                    try {
                        setAthlete(JSON.parse(storedAthlete));
                        // Fetch activities for returning user
                        fetch(`${window.APP_CONFIG.API_BASE_URL}/strava/activities?access_token=${accessToken}`)
                            .then(response => response.json())
                            .then(data => {
                                if (Array.isArray(data)) {
                                    setActivities(data);
                                    const totalDistance = data.reduce((sum, activity) => sum + activity.distance, 0) / 1000;
                                    const totalTime = data.reduce((sum, activity) => sum + activity.moving_time, 0) / 3600;
                                    setMainStats({
                                        distance: `${totalDistance.toFixed(1)} km`,
                                        time: `${totalTime.toFixed(1)} hrs`,
                                        count: data.length.toString()
                                    });
                                }
                            })
                            .catch(error => console.error('Error fetching activities:', error));
                    } catch (e) {
                        console.error('Error parsing stored athlete data:', e);
                        localStorage.clear();
                        setError('Error loading stored data');
                    }
                }
            }, []);

            if (!athlete) {
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center relative overflow-hidden">
                        <InteractiveBackground />
                        
                        <div className="relative glass rounded-xl p-8 max-w-md w-full mx-4 text-center">
                            <h1 className="text-4xl font-bold mb-6 text-white">
                                Strava Analytics
                            </h1>
                            <p className="text-lg mb-8 text-gray-300">
                                Get deeper insights into your training with AI-powered analytics
                            </p>
                            <div className="space-y-4">
                                <div className="flex items-center justify-center space-x-2 mb-6">
                                    <span className="w-3 h-3 bg-green-400 rounded-full"></span>
                                    <span className="text-gray-300">AI Coach</span>
                                    <span className="w-3 h-3 bg-blue-400 rounded-full ml-4"></span>
                                    <span className="text-gray-300">Smart Analytics</span>
                                    <span className="w-3 h-3 bg-purple-400 rounded-full ml-4"></span>
                                    <span className="text-gray-300">Race Predictions</span>
                                </div>
                                <button
                                    onClick={handleStravaConnect}
                                    className="w-full bg-strava-orange hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-200"
                                >
                                    Connect with Strava
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen">
                    <InteractiveBackground />

                    {/* Navigation */}
                    <nav className="glass fixed top-0 left-0 right-0 z-50">
                        <div className="max-w-7xl mx-auto px-2 sm:px-6 lg:px-8">
                            <div className="flex items-center justify-between h-14 sm:h-16">
                                <div className="flex items-center">
                                    <span className="text-lg sm:text-xl font-bold">Strava Analytics</span>
                                </div>
                                <div className="flex items-center space-x-2 sm:space-x-4">
                                    <img
                                        src={athlete.profile}
                                        alt="Profile"
                                        className="h-8 w-8 rounded-full"
                                    />
                                    <span className="hidden sm:inline">{athlete.firstname}</span>
                                    <button
                                        onClick={() => {
                                            localStorage.clear();
                                            window.location.href = '/';
                                        }}
                                        className="text-sm sm:text-base bg-red-500 hover:bg-red-600 text-white px-2 sm:px-3 py-1 rounded"
                                    >
                                        Logout
                                    </button>
                                </div>
                            </div>
                        </div>
                    </nav>

                    {/* Main Content */}
                    <main className="pt-16 sm:pt-20 px-2 sm:px-6 lg:px-8">
                        <div className="max-w-7xl mx-auto">
                            {/* Tabs */}
                            <div className="overflow-x-auto -mx-2 px-2 mb-4">
                                <div className="glass inline-flex rounded-lg p-1 whitespace-nowrap">
                                    <button
                                        onClick={() => setActiveTab('dashboard')}
                                        className={`px-2 sm:px-4 py-2 rounded-md text-sm sm:text-base ${
                                            activeTab === 'dashboard'
                                                ? 'bg-strava-orange text-white'
                                                : 'text-gray-300 hover:text-white'
                                        }`}
                                    >
                                        Dashboard
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('coach')}
                                        className={`px-2 sm:px-4 py-2 rounded-md text-sm sm:text-base ${
                                            activeTab === 'coach'
                                                ? 'bg-strava-orange text-white'
                                                : 'text-gray-300 hover:text-white'
                                        }`}
                                    >
                                        AI Coach
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('training')}
                                        className={`px-2 sm:px-4 py-2 rounded-md text-sm sm:text-base ${
                                            activeTab === 'training'
                                                ? 'bg-strava-orange text-white'
                                                : 'text-gray-300 hover:text-white'
                                        }`}
                                    >
                                        Training
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('races')}
                                        className={`px-2 sm:px-4 py-2 rounded-md text-sm sm:text-base ${
                                            activeTab === 'races'
                                                ? 'bg-strava-orange text-white'
                                                : 'text-gray-300 hover:text-white'
                                        }`}
                                    >
                                        Races
                                    </button>
                                </div>
                            </div>

                            {/* Content */}
                            <div className="glass rounded-lg p-3 sm:p-6">
                                {activeTab === 'dashboard' && (
                                    <ActivityFeed
                                        activities={activities}
                                        setActivities={setActivities}
                                        setMainStats={setMainStats}
                                        mainStats={mainStats}
                                    />
                                )}
                                {activeTab === 'coach' && (
                                    <AICoach activities={activities} />
                                )}
                                {activeTab === 'training' && (
                                    <TrainingLoad activities={activities} />
                                )}
                                {activeTab === 'races' && (
                                    <RacePredictions activities={activities} />
                                )}
                            </div>
                        </div>
                    </main>
                </div>
            );
        }

        // ActivityFeed Component
        function ActivityFeed({ activities, setActivities, setMainStats, mainStats }) {
            const [loading, setLoading] = React.useState(false);
            const [error, setError] = React.useState(null);
            const [timeRange, setTimeRange] = React.useState('1m');
            const [viewMode, setViewMode] = React.useState('week');
            const distanceChartRef = React.useRef(null);
            const timeChartRef = React.useRef(null);
            const paceChartRef = React.useRef(null);
            const [distanceChart, setDistanceChart] = React.useState(null);
            const [timeChart, setTimeChart] = React.useState(null);
            const [paceChart, setPaceChart] = React.useState(null);

            // Add data fetching logic
            const fetchActivities = async () => {
                setLoading(true);
                try {
                    const accessToken = localStorage.getItem('access_token');
                    if (!accessToken) return;

                    const response = await fetch(`${window.APP_CONFIG.API_BASE_URL}/strava/activities?access_token=${accessToken}`);
                    if (!response.ok) throw new Error('Failed to fetch activities');
                    
                    const data = await response.json();
                    if (Array.isArray(data)) {
                        setActivities(data);
                        
                        // Update main stats
                        const totalDistance = data.reduce((sum, activity) => sum + activity.distance, 0) / 1000;
                        const totalTime = data.reduce((sum, activity) => sum + activity.moving_time, 0) / 3600;
                        
                        setMainStats({
                            distance: `${totalDistance.toFixed(1)} km`,
                            time: `${totalTime.toFixed(1)} hrs`,
                            count: data.length.toString()
                        });
                    }
                } catch (err) {
                    console.error('Error fetching activities:', err);
                    setError('Failed to load activities');
                } finally {
                    setLoading(false);
                }
            };

            // Fetch data on component mount
            React.useEffect(() => {
                fetchActivities();
            }, []);

            // Filter activities based on time range
            const getFilteredActivities = () => {
                const now = dayjs();
                const ranges = {
                    '1w': now.subtract(1, 'week'),
                    '1m': now.subtract(1, 'month'),
                    '3m': now.subtract(3, 'months'),
                    '6m': now.subtract(6, 'months'),
                    '1y': now.subtract(1, 'year')
                };
                return activities.filter(activity => 
                    dayjs(activity.start_date).isAfter(ranges[timeRange])
                );
            };

            // Create charts when activities or time range changes
            React.useEffect(() => {
                if (activities.length > 0) {
                    // Cleanup existing charts
                    if (distanceChart) distanceChart.destroy();
                    if (timeChart) timeChart.destroy();
                    if (paceChart) paceChart.destroy();

                    createDistanceChart();
                    createTimeChart();
                    createPaceChart();
                }
            }, [activities, timeRange, viewMode]);

            const createDistanceChart = () => {
                const ctx = distanceChartRef.current.getContext('2d');
                const filteredActivities = getFilteredActivities();
                
                // Group by week or month and maintain chronological order
                const groupedData = Object.entries(filteredActivities.reduce((acc, activity) => {
                    const date = dayjs(activity.start_date);
                    const key = viewMode === 'week' 
                        ? date.startOf('week').format('YYYY-MM-DD')
                        : date.startOf('month').format('YYYY-MM');
                    
                    if (!acc[key]) acc[key] = 0;
                    acc[key] += activity.distance / 1000;
                    return acc;
                }, {})).sort(([dateA], [dateB]) => dayjs(dateA).diff(dayjs(dateB))); // Sort by date ascending

                const labels = groupedData.map(([date]) => 
                    viewMode === 'week' ? `Week of ${dayjs(date).format('MMM d')}` : dayjs(date).format('MMM YYYY')
                );

                const newChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Distance (km)',
                            data: groupedData.map(([_, value]) => value),
                            backgroundColor: 'rgba(252, 76, 2, 0.6)',
                            borderColor: 'rgba(252, 76, 2, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        animation: {
                            duration: 1000,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Distance Over Time',
                                color: 'white'
                            },
                            legend: {
                                labels: { color: 'white' }
                            }
                        },
                        scales: {
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'white',
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
                setDistanceChart(newChart);
            };

            const createTimeChart = () => {
                const ctx = timeChartRef.current.getContext('2d');
                const filteredActivities = getFilteredActivities();
                
                // Group by week or month and maintain chronological order
                const groupedData = Object.entries(filteredActivities.reduce((acc, activity) => {
                    const date = dayjs(activity.start_date);
                    const key = viewMode === 'week' 
                        ? date.startOf('week').format('YYYY-MM-DD')
                        : date.startOf('month').format('YYYY-MM');
                    
                    if (!acc[key]) acc[key] = 0;
                    acc[key] += activity.moving_time / 3600;
                    return acc;
                }, {})).sort(([dateA], [dateB]) => dayjs(dateA).diff(dayjs(dateB))); // Sort by date ascending

                const labels = groupedData.map(([date]) => 
                    viewMode === 'week' ? `Week of ${dayjs(date).format('MMM d')}` : dayjs(date).format('MMM YYYY')
                );

                const newChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Time (hours)',
                            data: groupedData.map(([_, value]) => value),
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        animation: {
                            duration: 1000,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Training Time',
                                color: 'white'
                            },
                            legend: {
                                labels: { color: 'white' }
                            }
                        },
                        scales: {
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'white' }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'white',
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
                setTimeChart(newChart);
            };

            const createPaceChart = () => {
                const ctx = paceChartRef.current.getContext('2d');
                const filteredActivities = getFilteredActivities()
                    .sort((a, b) => dayjs(a.start_date).diff(dayjs(b.start_date))); // Sort by date ascending
                
                // Calculate average pace for each activity
                const paceData = filteredActivities.map(activity => ({
                    date: activity.start_date,
                    pace: (activity.moving_time / 60) / (activity.distance / 1000) // minutes per km
                }));

                const newChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Pace (min/km)',
                            data: paceData.map(d => ({
                                x: new Date(d.date),
                                y: d.pace
                            })),
                            backgroundColor: 'rgba(139, 92, 246, 0.6)'
                        }]
                    },
                    options: {
                        responsive: true,
                        animation: {
                            duration: 1000,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Pace Trends',
                                color: 'white'
                            },
                            legend: {
                                labels: { color: 'white' }
                            }
                        },
                        scales: {
                            y: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'white',
                                    callback: value => `${Math.floor(value)}:${Math.round((value % 1) * 60).toString().padStart(2, '0')}`
                                }
                            },
                            x: {
                                type: 'time',
                                time: {
                                    unit: viewMode === 'week' ? 'day' : 'week',
                                    displayFormats: {
                                        day: 'MMM d',
                                        week: 'MMM d'
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'white',
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
                setPaceChart(newChart);
            };

            return (
                <div>
                    {/* Time Range and View Mode Controls */}
                    <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0 mb-6">
                        <div className="w-full sm:w-auto glass rounded-lg p-1 inline-flex space-x-1 overflow-x-auto">
                            {['1w', '1m', '3m', '6m', '1y'].map((range) => (
                                <button
                                    key={range}
                                    onClick={() => setTimeRange(range)}
                                    className={`flex-1 sm:flex-none px-2 sm:px-3 py-1 rounded text-sm ${
                                        timeRange === range
                                            ? 'bg-strava-orange text-white'
                                            : 'text-gray-300 hover:text-white'
                                    }`}
                                >
                                    {range.toUpperCase()}
                                </button>
                            ))}
                        </div>
                        <div className="w-full sm:w-auto glass rounded-lg p-1 inline-flex space-x-1">
                            {['week', 'month'].map((mode) => (
                                <button
                                    key={mode}
                                    onClick={() => setViewMode(mode)}
                                    className={`flex-1 sm:flex-none px-2 sm:px-3 py-1 rounded text-sm ${
                                        viewMode === mode
                                            ? 'bg-strava-orange text-white'
                                            : 'text-gray-300 hover:text-white'
                                    }`}
                                >
                                    By {mode}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Stats Overview */}
                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 sm:gap-6 mb-6">
                        <div className="glass rounded-lg p-3 sm:p-6 text-center">
                            <h3 className="text-sm sm:text-lg font-semibold text-gray-400">Distance</h3>
                            <p className="text-lg sm:text-3xl font-bold text-white">{mainStats.distance}</p>
                        </div>
                        <div className="glass rounded-lg p-3 sm:p-6 text-center">
                            <h3 className="text-sm sm:text-lg font-semibold text-gray-400">Time</h3>
                            <p className="text-lg sm:text-3xl font-bold text-white">{mainStats.time}</p>
                        </div>
                        <div className="glass rounded-lg p-3 sm:p-6 text-center col-span-2 sm:col-span-1">
                            <h3 className="text-sm sm:text-lg font-semibold text-gray-400">Activities</h3>
                            <p className="text-lg sm:text-3xl font-bold text-white">{mainStats.count}</p>
                        </div>
                    </div>

                    {/* Charts */}
                    <div className="space-y-4 sm:space-y-6">
                        <div className="glass p-3 sm:p-6 rounded-lg h-[300px] sm:h-[400px]">
                            <canvas ref={distanceChartRef}></canvas>
                        </div>
                        <div className="glass p-3 sm:p-6 rounded-lg h-[300px] sm:h-[400px]">
                            <canvas ref={timeChartRef}></canvas>
                        </div>
                        <div className="glass p-3 sm:p-6 rounded-lg h-[300px] sm:h-[400px]">
                            <canvas ref={paceChartRef}></canvas>
                        </div>
                    </div>

                    {/* Activities List */}
                    <div className="mt-6">
                        <h3 className="text-lg sm:text-xl font-semibold mb-3">Recent Activities</h3>
                        <div className="space-y-3">
                            {getFilteredActivities().slice(0, 5).map((activity) => (
                                <div key={activity.id} className="glass rounded-lg p-3 sm:p-4">
                                    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
                                        <div>
                                            <h4 className="text-base sm:text-lg font-semibold">{activity.name}</h4>
                                            <p className="text-xs sm:text-sm text-gray-400">
                                                {dayjs(activity.start_date).format('MMM d, YYYY')} â€¢ {(activity.distance / 1000).toFixed(1)} km
                                            </p>
                                        </div>
                                        <div className="mt-2 sm:mt-0 text-right">
                                            <p className="text-xs sm:text-sm text-gray-400">{Math.floor(activity.moving_time / 60)} mins</p>
                                            <p className="text-xs sm:text-sm text-gray-400">{((activity.average_speed * 3.6).toFixed(1))} km/h</p>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        // Render the App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html> 